#include <bits/stdc++.h>
using namespace std;
// 64ビット長の符号付き整数
// 疑問:long longとの使い分け
using ll = int64_t;

int main(){
    ll N, C;
    cin >> N >> C;
    vector<pair<ll, ll>> event;
    for(ll i = 0; i < N; i++){
        ll a, b, c;
        cin >> a >> b >> c;
        // 新たな要素を末尾に追加する。
        // ai−1日目とai日目の間に料金がci円上がるイベントが起こるbi日目
        event.emplace_back(a - 1, c);
        // bi+1日目の間に料金がci円下がるイベントが起こる
        event.emplace_back(b, -c);
    }
    sort(event.begin(), event.end());
    ll ans = 0, fee = 0, t = 0;
    for(auto [x, y] : event){
        if(x != t){
            //#0 min(100000,0) * (5797761 - 0)
            //#1 min(100000,65697) * (54601290 - 5797761)
            //#2 min(100000,50554) * (136808999 - 5797761)
            ans += min(C, fee) * (x - t);
            // 5797761
            // 54601290
            t = x;
        }
        //サービスが終了した際は-料金でfeeを下げる
        fee += y;
    }
    cout << ans << endl;
}

// 解説
// すぬけプライムは毎日加入及び脱退ができるので、
// その日支払う料金がC円を超えそうならサブスクリプションを利用し、
// 超えないなら利用しないようにするのが最適です。
// そこで、s[i]=(すぬけプライムを利用しない場合のi日目に支払う料金)を求めたいです。
// iの範囲が小さければいもす法で求めることができますが、
// 今回はiの範囲が大きいので、なにか工夫する必要があります。
// 例えば、以下のようにすれば良いです。
// ai日目からbi日目まで利用するci円のサービスを、
// ai−1日目とai日目の間に料金がci円上がるイベントが起こるbi日目と
// bi+1日目の間に料金がci円下がるイベントが起こると言い換え、
// これらのイベントを時間でソートします。
// そして、イベントを前から見ていきながら、今何日目を見ているのかと現在の料金の変数を更新していくと、この問題をO(NlogN)で解くことができます。
